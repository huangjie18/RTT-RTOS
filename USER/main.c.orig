#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"


/************************************************
 ALIENTEK战舰STM32开发板实验1
 跑马灯实验
 技术支持：www.openedv.com
 淘宝店铺：http://eboard.taobao.com
 关注微信公众平台微信号："正点原子"，免费获取STM32资料。
 广州市星翼电子科技有限公司
 作者：正点原子 @ALIENTEK
************************************************/

#include <rtthread.h>
static struct rt_thread led0_thread;//线程控制块
static struct rt_thread led1_thread;//线程控制块
ALIGN(RT_ALIGN_SIZE)
static rt_uint8_t rt_led0_thread_stack[1024];//线程栈
static rt_uint8_t rt_led1_thread_stack[1024];//线程栈

//线程 LED0
static void led0_thread_entry(void* parameter)
{
    while(1)
    {
        LED0 = 0; //注意： F7 不支持位带操作， LED 操作请参考代码修改
        rt_thread_delay(RT_TICK_PER_SECOND / 5); //延时
        LED0 = 1;
        rt_thread_delay(RT_TICK_PER_SECOND / 5); //延时
    }
}

//线程 LED1
static void led1_thread_entry(void* parameter)
{
    while(1)
    {
        LED1 = 0;
        rt_thread_delay(RT_TICK_PER_SECOND / 2); //延时
        LED1 = 1;
        rt_thread_delay(RT_TICK_PER_SECOND / 2); //延时
    }
}


int main(void)
{
    delay_init();       //延时函数初始化
    LED_Init();         //初始化与LED连接的硬件接口
// 创建静态线程
rt_thread_init(&led0_thread, //线程控制块
"led0", //线程名字，在 shell 里面可以看到
led0_thread_entry, //线程入口函数
RT_NULL, //线程入口函数参数
&rt_led0_thread_stack[0], //线程栈起始地址
sizeof(rt_led0_thread_stack), //线程栈大小
3, //线程的优先级
20); //线程时间片
rt_thread_startup(&led0_thread); /启动线程 led0_thread，开启调度
rt_thread_init(&led1_thread, //线程控制块
"led1", //线程名字，在 shell 里面可以看到
led1_thread_entry, //线程入口函数
RT_NULL, //线程入口函数参数
&rt_led1_thread_stack[0], //线程栈起始地址
sizeof(rt_led1_thread_stack), //线程栈大小
3, //线程的优先级
20);
rt_thread_startup(&led1_thread); //启动线程 led1_thread，开启调度
}
}


/**
*****************下面注视的代码是通过调用库函数来实现IO控制的方法*****************************************
int main(void)
{

delay_init();        //初始化延时函数
LED_Init();                //初始化LED端口
while(1)
{
       GPIO_ResetBits(GPIOB,GPIO_Pin_5);  //LED0对应引脚GPIOB.5拉低，亮  等同LED0=0;
       GPIO_SetBits(GPIOE,GPIO_Pin_5);   //LED1对应引脚GPIOE.5拉高，灭 等同LED1=1;
       delay_ms(300);             //延时300ms
       GPIO_SetBits(GPIOB,GPIO_Pin_5);    //LED0对应引脚GPIOB.5拉高，灭  等同LED0=1;
       GPIO_ResetBits(GPIOE,GPIO_Pin_5); //LED1对应引脚GPIOE.5拉低，亮 等同LED1=0;
       delay_ms(300);                     //延时300ms
}
}

****************************************************************************************************
***/



/**
*******************下面注释掉的代码是通过 直接操作寄存器 方式实现IO口控制**************************************
int main(void)
{

    delay_init();         //初始化延时函数
    LED_Init();             //初始化LED端口
    while(1)
    {
     GPIOB->BRR=GPIO_Pin_5;//LED0亮
       GPIOE->BSRR=GPIO_Pin_5;//LED1灭
         delay_ms(300);
     GPIOB->BSRR=GPIO_Pin_5;//LED0灭
       GPIOE->BRR=GPIO_Pin_5;//LED1亮
         delay_ms(300);

     }
 }
**************************************************************************************************
**/

